\chapter{Validation and Testing}
\label{cha:validation}
\section{Testing}
During our initial discussions, we made some simple plans for how we would attempt to test each part of our program. Since each member of the team would be writing some parts of the code, it seemed to make sense that whoever wrote the code should test it as well. We decided that it would be a good idea to use JUnit tests, since these allowed for the mass testing of all classes in the program once everything was written. If we were to use another testing method, it would likely result in having to run some part of the program and check that its output was correct, or use a multitude of print statements to check that the program was running correctly, which would lead to having to trawl through a significant amount of data and pick out relevant parts, which would likely be very difficult to find, given that bugs do not necessarily occur frequently, and when they do, the signs are not obvious when looking at output. Once we had actually started the project, however, it became obvious that many parts of the game were not conducive to testing. For example, testing controls with JUnit is possible, but not particularly easy. The easiest way of testing the controls is simply to play the game, see if there are any problems, and then attempt to fix them. As development progressed, we discovered that writing tests before or after writing code meant that our development speed slowed significantly. We would spend quite a while writing tests to make sure that relatively simple parts of the code worked correctly, when it was obvious from playing the game that everything was as expected. Eventually, we decided that using JUnit was slowing us down too much, and did not actually provide as much benefit as we had initially hoped that it would provide, and we each used testing methods that we usually used when programming. Mostly, this involved reading the output at specific parts of the program that we knew would contain problems. Of course, testing was only done if something didn't work properly---there was no need to test something that didn't seem to be broken. Since we were running the game regularly and playing it to check if the code we had written was doing what it was supposed to, we believe that any bugs we had were spotted far more quickly this way than by laboriously writing JUnit tests and then using them to check that everything was working properly. By playing the game, we could test all the conditions that we would expect the code to work in, and if anything was broken, we would move to the output reading method, which in most cases worked without a problem. Printing out variables or arrays to see their current state allowed us to quickly see where the problem lay. There were a few times where this method did not allow us to solve the problem, and in these cases we went to the built in debug tool in netbeans. By stepping through each part of the program, or parts of the program that we thought were causing the d problem we could see the state of all variables in an organised way, and to step into methods that were part of the execution process, to check if there was some kind of error we were making in the order that code was executed.

We think that the main problem with the lack of success of the JUnit tests was the fact that the code distribution between members was not particularly even. As such, some members perhaps didn't understand the workings of a certain part of the program enough to write a test for it, and so tests were left unwritten. Since towards the end of development, there were only really two of us working on the code, we did not have sufficient time to test the entire code base, as we had to concentrate on writing the parts of the code that were required to complete the program. Perhaps if we had split the work in a more appropriate way, to allow everyone to work on some part, rather than ending up with two of us working on everything, we would have had enough time to write proper tests for everything. Another way that we could have solved this problem would have been to have one member who was responsible for testing all of the code, and not write any actual game code themselves. However, this person's understanding of code would have had to have been better than that of those writing the code, in order to be able to test everything correctly. Given the skill levels of members in our team, it is unlikely that this would have been possible, as the majority of the code would probably have not been written, since the person with the best understanding of code would probably be the one who would be needed to write most of the complex code, and other team members would likely be unable to test the code that that person would have written. Overall, however, apart from the networking code, we believe that everything has been tested to a relatively satisfactory standard by using only the testing methods that we have used. No major bugs in the code have been discovered yet, and as far as we are aware, the minor bugs have no real impact on gameplay.
\section{Validation}