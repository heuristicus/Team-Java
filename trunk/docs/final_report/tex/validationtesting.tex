\chapter{Validation and Testing}
\label{cha:validation}
\section{Testing}
During our initial discussions, we made some simple plans for how we would attempt to test each part of our program. Since each member of the team would be writing some parts of the code, it seemed to make sense that whoever wrote the code should test it as well. We decided that it would be a good idea to use JUnit tests, since these allowed for the mass testing of all classes in the program once everything was written. If we were to use another testing method, it would likely result in having to run some part of the program and check that its output was correct, or use a multitude of print statements to check that the program was running correctly, which would lead to having to trawl through a significant amount of data and pick out relevant parts, which would likely be very difficult to find, given that bugs do not necessarily occur frequently, and when they do, the signs are not obvious when looking at output. Once we had actually started the project, however, it became obvious that many parts of the game were not conducive to testing. For example, testing controls with JUnit is possible, but not particularly easy.\\\\
The easiest way of testing the controls is simply to play the game, see if there are any problems, and then attempt to fix them. As development progressed, we discovered that writing tests before or after writing code meant that our development speed slowed significantly. We would spend quite a while writing tests to make sure that relatively simple parts of the code worked correctly, when it was obvious from playing the game that everything was as expected. Eventually, we decided that using JUnit was slowing us down too much, and did not actually provide as much benefit as we had initially hoped that it would provide, and we each used testing methods that we usually used when programming. Mostly, this involved reading the output at specific parts of the program that we knew would contain problems.\\\\
Of course, testing was only done if something didn't work properly---there was no need to test something that didn't seem to be broken. Since we were running the game regularly and playing it to check if the code we had written was doing what it was supposed to, we believe that any bugs we had were spotted far more quickly this way than by laboriously writing JUnit tests and then using them to check that everything was working properly. By playing the game, we could test all the conditions that we would expect the code to work in, and if anything was broken, we would move to the output reading method, which in most cases worked without a problem. Printing out variables or arrays to see their current state allowed us to quickly see where the problem lay. There were a few times where this method did not allow us to solve the problem, and in these cases we went to the built in debug tool in netbeans. By stepping through each part of the program, or parts of the program that we thought were causing the d problem we could see the state of all variables in an organised way, and to step into methods that were part of the execution process, to check if there was some kind of error we were making in the order that code was executed.\\\\
We think that the main problem with the lack of success of the JUnit tests was the fact that the code distribution between members was not particularly even. As such, some members perhaps didn't understand the workings of a certain part of the program enough to write a test for it, and so tests were left unwritten. Since towards the end of development, there were only really two of us working on the code, we did not have sufficient time to test the entire code base, as we had to concentrate on writing the parts of the code that were required to complete the program. Perhaps if we had split the work in a more appropriate way, to allow everyone to work on some part, rather than ending up with two of us working on everything, we would have had enough time to write proper tests for everything. Another way that we could have solved this problem would have been to have one member who was responsible for testing all of the code, and not write any actual game code themselves. However, this person's understanding of code would have had to have been better than that of those writing the code, in order to be able to test everything correctly. Given the skill levels of members in our team, it is unlikely that this would have been possible, as the majority of the code would probably have not been written, since the person with the best understanding of code would probably be the one who would be needed to write most of the complex code, and other team members would likely be unable to test the code that that person would have written. Overall, however, apart from the networking code, we believe that everything has been tested to a relatively satisfactory standard by using only the testing methods that we have used. No major bugs in the code have been discovered yet, and as far as we are aware, the minor bugs have no real impact on gameplay.
\section{Validation}
This section compares the game's performance against the specifications that were originally outlined in the earlier section.
\subsection{Functional}
\begin{enumerate}
\item \textbf{The human player is able to control one's spaceship}
This was validated by each member of the team. As this is such a central part of the game, controls were tested almost every time the game was run, and so this section is well checked. The controls used can either be keyboard or mouse. The spaceship of the user is able to move freely, but can leave the frame boundaries when using the mouse to control it. The diagonal movement of the ship is not normalised, and therefore diagonal travel is slower than travel along a single axis. When using a mouse, this is no longer a problem. The spaceship is represented by a graphical sprite, whose image can be easily changed.
\item \textbf{The human player will be able to shoot}
Shooting is again a central part of the game, and so was tested often. In initial stages, tests were done with JUnit, and then later on through playing the game. Projectiles which are no longer visible are removed from the game so that they no longer need to be processed.
\item \textbf{Enemies will be created to be destroyed by the user}
Enemies are created at regular intervals and can be destroyed by the user once then are hit with enough projectiles. Each enemy has a specific amount of health and is destroyed once this value reaches zero, usually after being hit by player projectiles. Boss enemies are also created with a small chance, and these have different firing patterns and health the the standard enemies. Enemies have a different sprite to the player, which can be changed easily if necessary.
\item \textbf{Enemies are to be able to return a level of resistance}
There is a significant amount of resistance to the player's progress. Enemies fire a large number of projectiles in a variety of different paths. In particular, boss enemies use weapons that fire rapidly and produce a large number of projectiles. Enemies have fixed paths depending on their type. These paths are different for normal and boss enemies. Boss enemies will stay on the screen until they are destroyed. Colliding with any enemy or too many enemy projectiles will cause the player to die.
\item \textbf{The game is to run continuously with set events occurring at regular intervals}
While the game is running, the game loop spawns enemies at specific time intervals. Enemies will keep spawning until the player dies. The enemies move each time the game logic is updated, which is every tick of the timer. The difficulty of the game can be controlled by increasing the rate at which the timer fires events.
\item \textbf{The game will be able to be multiplayer across the network}
It is possible to play the game with multiple players, although the game has not been tested with more than two players. Upon choosing the multiplayer option, players can choose to host a game or to find a game already running. Hosting will put you into a game, and you can wait for players to connect. A client will input the IP and port number of the server and will be connected. When the client connects, it drops into the server's game with a new player spawned that is controlled by the client user. The game can be connected over a network. During gameplay, users can see ship locations and projectiles the same as on any other screen. There are some problems with projectiles not correctly displaying, and some duplicate players appearing behind the actual position of the client player, but this is only present on the client's screen. The positions of all objects on the screen are updated each tick, when the logic is executed on the server. The execution of the logic also sends the server gamestate to clients.
\item \textbf{The game must have a terminating clause}
The game ends when the player loses all their health or collides with an enemy. The player score is displayed during the game, but not on the game over screen. The score is not stored anywhere, as there is no facility to do this.
\item \textbf{The game will include a Graphical User Interface (GUI)}
The game has a basic graphical user interface. When the game is run, the user chooses options for games by clicking buttons displayed on the screen. The game is all run in a single frame, with panels being switched out depending on the state of the game. The menu can be accessed at any time by pressing the escape button, and the game can be paused with the P key. The window can be resized, but the background does not draw correctly when this is done, and enemies do not spawn all over the screen, but remain in the top left side of the screen. Both the game panel and menus feature an aesthetically pleasing starry background, which gives the user the impression of flying through space. Each projectile type and players and enemies are represented by a graphical sprite.
\end{enumerate}
\subsection{Non-functional}
\begin{enumerate}
\setcounter{enumi}{8}
\item \textbf{To provide a simple, easy to use system in order to play the game}
To validate this requirement the team enlisted the help of several people outside of the game's development environment which is an example of alpha, or acceptance, testing. The game was first given to a young novice player and instructed to play the game as if they had just downloaded it for the first time. The team observed the player while they did so and came to the following conclusions. The player was able to navigate the menu very easily and was into the actual gameplay within just a few seconds of launching the program. However, the game soon became difficult resulting in the player's unit 'dying' within around twenty seconds. The user continued to relaunch and play the game for around 15 minutes. That person agreed that the menu system was easy to use with a clean look and feel. It took about 12 minutes before the user had a good run and became used to the game. This was slightly longer than the anticipated 10 minutes but is still acceptable for use.\\ Similarly, the team asked an expert gamer from Computer Science to test the game and agreed with the earlier comments but became familiar with the game after just a few runs.
\item \textbf{The game should be quick to respond}
With this requirement, all members of the team ran their own tests playing the game after it had been implemented. It was noticed that the game starts to lag after around 2-3 minutes of continuous gameplay. This bug had only been first noticed with only one week until the deadline. The team set about discovering why this way - the arrays which hold the objects to be drawn were not too large and had been pruned correctly so the bug still exists. However, at first the game is very responsive to the user's input having an almost instant affect on the gameplay. Network testing showed up no errors and worked every time the program was run (over 20 times). However, if the user is trying to do something out of what they should be it crashes. For example if the user tries to connect to a host in multi-player mode but inputs the wrong IP address or the host is not there, it crashes without any dialogue boxes.
\item \textbf{The game should run first time, all the time}
To test this requirement the game was run over and over again 20 times. The team added various outputs to the console (print line statements) to show what the game was doing. For example, the game would output a message when the controls were enabled, various networking messages as well as outputting which key was being pressed. Two people would observe this test; one to play the game and the other to look at the output messages. This test was successful and the game didn't crash once.
\item \textbf{Network clients should be able to drop-in within 5 seconds}
Again to test this requirement the game was run multiple times. The drop-in occurred almost instantly when it was being played on the same machine (localhost IP) and in around 1-2 seconds when using a LAN router. It is not possible to play over a WAN currently.
\item \textbf{The game should run on the platform detailed in system requirements.}
This test was noticed early on; the team all have various platforms to develop on (Mac OSX, Windows 7, Windows XP and Ubuntu Linux). The game managed to run the same on all platforms with no major differences (frame theming changed due to operating system designs).
\item \textbf{The project should be developed using appropriate software engineering practises within the time frame for the assessment.} The team used the incremental software life-cycle as detailed in the team management section of this report, the team also produced a Gantt chart showing the time frame for the assessment and, although there were some delays, the project was delivered on time (both the report and software).
\item \textbf{The project must be written in the Java programming language.}
This was a core requirement of the module, the team managed to use the Java API as well as other lecture notes to produce the software. The team was familiar with the Java language as it had been studied in previous degree modules and only certain aspects (e.g. networking) needed to be researched.
\item \textbf{The multi-player game must be able to run on any LAN with the IP addresses given.}
During the testing phases, the game was tested on multiple LANs and locations and all seemed to work perfectly fine. It is also possible to run two versions of the game on one machine and use the "localhost" IP address - although the game isn't really playable as the same controls are used for both copies of the game.
\item \textbf{High scores will remain stored in each copy of the game until they are overridden by a higher score.}
This requirement was not possible to test as the functionality had not been added to the game yet. The game did however display a score during the game in the bottom right-hand corner of the screen but no scores were recorded. This would be an easy modification to implement by writing the scores to an external file and using algorithms to check if a high score had been beaten.
\end{enumerate}