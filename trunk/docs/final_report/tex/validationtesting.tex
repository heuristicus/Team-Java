\chapter{Validation and Testing}
\label{cha:validation}
\section{Testing}
During our initial discussions, we made some simple plans for how we would attempt to test each part of our program. Since each member of the team would be writing some parts of the code, it seemed to make sense that whoever wrote the code should test it as well. We decided that it would be a good idea to use JUnit tests, since these allowed for the mass testing of all classes in the program once everything was written. If we were to use another testing method, it would likely result in having to run some part of the program and check that its output was correct, or use a multitude of print statements to check that the program was running correctly, which would lead to having to trawl through a significant amount of data and pick out relevant parts, which would likely be very difficult to find, given that bugs do not necessarily occur frequently, and when they do, the signs are not obvious when looking at output. Once we had actually started the project, however, it became obvious that many parts of the game were not conducive to testing. For example, testing controls with JUnit is possible, but not particularly easy. The easiest way of testing the controls is simply to play the game, see if there are any problems, and then attempt to fix them. As development progressed, we discovered that writing tests before or after writing code meant that our development speed slowed significantly. We would spend quite a while writing tests to make sure that relatively simple parts of the code worked correctly, when it was obvious from playing the game that everything was as expected. Eventually, we decided that using JUnit was slowing us down too much, and did not actually provide as much benefit as we had initially hoped that it would provide, and we each used testing methods that we usually used when programming. Mostly, this involved reading the output at specific parts of the program that we knew would contain problems. Of course, testing was only done if something didn't work properly---there was no need to test something that didn't seem to be broken. Since we were running the game regularly and playing it to check if the code we had written was doing what it was supposed to, we believe that any bugs we had were spotted far more quickly this way than by laboriously writing JUnit tests and then using them to check that everything was working properly. By playing the game, we could test all the conditions that we would expect the code to work in, and if anything was broken, we would move to the output reading method, which in most cases worked without a problem. Printing out variables or arrays to see their current state allowed us to quickly see where the problem lay. There were a few times where this method did not allow us to solve the problem, and in these cases we went to the built in debug tool in netbeans. By stepping through each part of the program, or parts of the program that we thought were causing the d problem we could see the state of all variables in an organised way, and to step into methods that were part of the execution process, to check if there was some kind of error we were making in the order that code was executed.

We think that the main problem with the lack of success of the JUnit tests was the fact that the code distribution between members was not particularly even. As such, some members perhaps didn't understand the workings of a certain part of the program enough to write a test for it, and so tests were left unwritten. Since towards the end of development, there were only really two of us working on the code, we did not have sufficient time to test the entire code base, as we had to concentrate on writing the parts of the code that were required to complete the program. Perhaps if we had split the work in a more appropriate way, to allow everyone to work on some part, rather than ending up with two of us working on everything, we would have had enough time to write proper tests for everything. Another way that we could have solved this problem would have been to have one member who was responsible for testing all of the code, and not write any actual game code themselves. However, this person's understanding of code would have had to have been better than that of those writing the code, in order to be able to test everything correctly. Given the skill levels of members in our team, it is unlikely that this would have been possible, as the majority of the code would probably have not been written, since the person with the best understanding of code would probably be the one who would be needed to write most of the complex code, and other team members would likely be unable to test the code that that person would have written. Overall, however, apart from the networking code, we believe that everything has been tested to a relatively satisfactory standard by using only the testing methods that we have used. No major bugs in the code have been discovered yet, and as far as we are aware, the minor bugs have no real impact on gameplay.
\section{Validation}
\subsection{Functional}
\begin{enumerate}
\item \textbf{The human player is able to control one's spaceship}
This was validated by each member of the team. As this is such a central part of the game, controls were tested almost every time the game was run, and so this section is well checked. The controls used can either be keyboard or mouse. The spaceship of the user is able to move freely, but can leave the frame boundaries when using the mouse to control it. The diagonal movement of the ship is not normalised, and therefore diagonal travel is slower than travel along a single axis. When using a mouse, this is no longer a problem. The spaceship is represented by a graphical sprite, whose image can be easily changed.
\item \textbf{The human player will be able to shoot}
Shooting is again a central part of the game, and so was tested often. In initial stages, tests were done with JUnit, and then later on through playing the game. Projectiles which are no longer visible are removed from the game so that they no longer need to be processed.
\item \textbf{Enemies will be created to be destroyed by the user}
Enemies are created at regular intervals and can be destroyed by the user once then are hit with enough projectiles. Each enemy has a specific amount of health and is destroyed once this value reaches zero, usually after being hit by player projectiles. Boss enemies are also created with a small chance, and these have different firing patterns and health the the standard enemies. Enemies have a different sprite to the player, which can be changed easily if necessary.
\item \textbf{Enemies are to be able to return a level of resistance}
There is a significant amount of resistance to the player's progress. Enemies fire a large number of projectiles in a variety of different paths. In particular, boss enemies use weapons that fire rapidly and produce a large number of projectiles. Enemies have fixed paths depending on their type. These paths are different for normal and boss enemies. Boss enemies will stay on the screen until they are destroyed. Colliding with any enemy or too many enemy projectiles will cause the player to die.
\item \textbf{The game is to run continuously with set events occurring at regular intervals}
While the game is running, the game loop spawns enemies at specific time intervals. Enemies will keep spawning until the player dies. The enemies move each time the game logic is updated, which is every tick of the timer. The difficulty of the game can be controlled by increasing the rate at which the timer fires events.
\item \textbf{The game will be able to be multiplayer across the network}
It is possible to play the game with multiple players, although the game has not been tested with more than two players. Upon choosing the multiplayer option, players can choose to host a game or to find a game already running. Hosting will put you into a game, and you can wait for players to connect. A client will input the IP and port number of the server and will be connected. When the client connects, it drops into the server's game with a new player spawned that is controlled by the client user. The game can be connected over a network. During gameplay, users can see ship locations and projectiles the same as on any other screen. There are some problems with projectiles not correctly displaying, and some duplicate players appearing behind the actual position of the client player, but this is only present on the client's screen. The positions of all objects on the screen are updated each tick, when the logic is executed on the server. The execution of the logic also sends the server gamestate to clients.
\item \textbf{The game must have a terminating clause}
The game ends when the player loses all their health or collides with an enemy. The player score is displayed during the game, but not on the game over screen. The score is not stored anywhere, as there is no facility to do this.
\item \textbf{The game will include a Graphical User Interface (GUI)}
The game has a basic graphical user interface. When the game is run, the user chooses options for games by clicking buttons displayed on the screen. The game is all run in a single frame, with panels being switched out depending on the state of the game. The menu can be accessed at any time by pressing the escape button, and the game can be paused with the P key. The window can be resized, but the background does not draw correctly when this is done, and enemies do not spawn all over the screen, but remain in the top left side of the screen. Both the game panel and menus feature an aesthetically pleasing starry background, which gives the user the impression of flying through space. Each projectile type and players and enemies are represented by a graphical sprite.
\end{enumerate}